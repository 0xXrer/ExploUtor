local HttpService = game:GetService("HttpService")

local ExploUtor = {}
ExploUtor.__index = ExploUtor

local ws = nil
local requestId = 0
local pendingRequests = {}
local remoteSpyEnabled = false
local closureSpyEnabled = false
local remoteSpyConnection = nil
local closureHooks = {}

local function generateId()
    return HttpService:GenerateGUID(false)
end

local function serialize(value, depth)
    depth = depth or 0
    if depth > 10 then return "..." end
    
    local t = typeof(value)
    
    if t == "string" then
        return string.format("%q", value)
    elseif t == "number" or t == "boolean" then
        return tostring(value)
    elseif t == "nil" then
        return "nil"
    elseif t == "table" then
        local parts = {}
        for k, v in pairs(value) do
            local key = type(k) == "string" and k or "[" .. serialize(k, depth + 1) .. "]"
            table.insert(parts, key .. " = " .. serialize(v, depth + 1))
        end
        return "{" .. table.concat(parts, ", ") .. "}"
    elseif t == "Instance" then
        return value:GetFullName()
    elseif t == "function" then
        local info = debug.info(value, "sln")
        return string.format("function<%s:%d>", info or "unknown", 0)
    else
        return tostring(value)
    end
end

local function sendResponse(id, result, err)
    if not ws then return end
    
    local response = {
        jsonrpc = "2.0",
        id = id
    }
    
    if err then
        response.error = { code = -32000, message = err }
    else
        response.result = result
    end
    
    ws:Send(HttpService:JSONEncode(response))
end

local function sendNotification(method, params)
    if not ws then return end
    
    local notification = {
        jsonrpc = "2.0",
        method = method,
        params = params
    }
    
    ws:Send(HttpService:JSONEncode(notification))
end

local function getPlaceInfo()
    local place = game.PlaceId
    local info = {
        placeId = place,
        placeName = game:GetService("MarketplaceService"):GetProductInfo(place).Name,
        creatorId = game.CreatorId,
        creatorName = game.CreatorType == Enum.CreatorType.User 
            and game:GetService("Players"):GetNameFromUserIdAsync(game.CreatorId) 
            or "Group",
        creatorType = tostring(game.CreatorType),
        maxPlayers = game:GetService("Players").MaxPlayers,
        serverSize = #game:GetService("Players"):GetPlayers()
    }
    return info
end

local function scanUpvalues()
    local upvalues = {}
    
    for _, func in ipairs(getgc(true)) do
        if typeof(func) == "function" and not iscclosure(func) then
            local info = debug.info(func, "sln")
            local closureId = generateId()
            
            for i = 1, debug.info(func, "a") or 0 do
                local success, name, value = pcall(function()
                    return debug.getupvalue(func, i)
                end)
                
                if success and name then
                    table.insert(upvalues, {
                        id = generateId(),
                        closureId = closureId,
                        closureName = debug.info(func, "n") or "anonymous",
                        closureLocation = info or "unknown",
                        index = i,
                        name = name,
                        value = serialize(value),
                        type = typeof(value)
                    })
                end
            end
        end
    end
    
    return { upvalues = upvalues }
end

local function scanConstants()
    local constants = {}
    
    for _, func in ipairs(getgc(true)) do
        if typeof(func) == "function" and not iscclosure(func) then
            local info = debug.info(func, "sln")
            local closureId = generateId()
            
            local success, consts = pcall(debug.getconstants or getconstants, func)
            if success and consts then
                for i, value in pairs(consts) do
                    if value ~= nil then
                        table.insert(constants, {
                            id = generateId(),
                            closureId = closureId,
                            closureName = debug.info(func, "n") or "anonymous",
                            closureLocation = info or "unknown",
                            index = i,
                            value = serialize(value),
                            type = typeof(value)
                        })
                    end
                end
            end
        end
    end
    
    return { constants = constants }
end

local function scanScripts()
    local scripts = {}
    
    local function scanContainer(container)
        for _, child in ipairs(container:GetDescendants()) do
            if child:IsA("LocalScript") then
                local source = ""
                pcall(function()
                    source = decompile(child)
                end)
                
                table.insert(scripts, {
                    id = generateId(),
                    name = child.Name,
                    path = child:GetFullName(),
                    className = child.ClassName,
                    source = source,
                    protosCount = 0,
                    constantsCount = 0,
                    upvaluesCount = 0
                })
            end
        end
    end
    
    pcall(function() scanContainer(game:GetService("Players").LocalPlayer.PlayerScripts) end)
    pcall(function() scanContainer(game:GetService("Players").LocalPlayer.PlayerGui) end)
    pcall(function() scanContainer(game:GetService("ReplicatedFirst")) end)
    pcall(function() scanContainer(game:GetService("ReplicatedStorage")) end)
    
    return { scripts = scripts }
end

local function scanModules()
    local modules = {}
    
    local function scanContainer(container)
        for _, child in ipairs(container:GetDescendants()) do
            if child:IsA("ModuleScript") then
                local source = ""
                local returnValue = ""
                local returnType = "unknown"
                
                pcall(function()
                    source = decompile(child)
                end)
                
                pcall(function()
                    local result = require(child)
                    returnValue = serialize(result)
                    returnType = typeof(result)
                end)
                
                table.insert(modules, {
                    id = generateId(),
                    name = child.Name,
                    path = child:GetFullName(),
                    className = child.ClassName,
                    source = source,
                    protosCount = 0,
                    constantsCount = 0,
                    upvaluesCount = 0,
                    returnValue = returnValue,
                    returnType = returnType
                })
            end
        end
    end
    
    pcall(function() scanContainer(game:GetService("ReplicatedStorage")) end)
    pcall(function() scanContainer(game:GetService("Players").LocalPlayer.PlayerScripts) end)
    
    return { modules = modules }
end

local function getRemotes()
    local remotes = {}
    
    for _, child in ipairs(game:GetDescendants()) do
        if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
            table.insert(remotes, {
                name = child.Name,
                path = child:GetFullName(),
                type = child.ClassName
            })
        end
    end
    
    return { remotes = remotes }
end

local function executeCode(code)
    local success, result = pcall(function()
        local fn, err = loadstring(code)
        if not fn then
            error(err)
        end
        return fn()
    end)
    
    if success then
        return {
            success = true,
            output = result and serialize(result) or ""
        }
    else
        return {
            success = false,
            error = tostring(result)
        }
    end
end

local function modifyUpvalue(params)
    for _, func in ipairs(getgc(true)) do
        if typeof(func) == "function" then
            local closureId = generateId()
            if closureId == params.closureId then
                local value = params.value
                if params.valueType == "number" then
                    value = tonumber(value)
                elseif params.valueType == "boolean" then
                    value = value == "true"
                elseif params.valueType == "nil" then
                    value = nil
                end
                
                debug.setupvalue(func, params.upvalueIndex, value)
                return { success = true }
            end
        end
    end
    
    return { success = false, error = "Closure not found" }
end

local function enableRemoteSpy(enabled)
    remoteSpyEnabled = enabled
    
    if enabled and not remoteSpyConnection then
        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if (method == "FireServer" or method == "InvokeServer") and self:IsA("RemoteEvent") or self:IsA("RemoteFunction") then
                if remoteSpyEnabled then
                    sendNotification("remote_called", {
                        id = generateId(),
                        timestamp = os.time() * 1000,
                        remoteName = self.Name,
                        remotePath = self:GetFullName(),
                        remoteType = self.ClassName,
                        arguments = serialize(args),
                        caller = debug.info(2, "sln") or "unknown",
                        traceback = debug.traceback()
                    })
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        remoteSpyConnection = true
    end
end

local function enableClosureSpy(enabled)
    closureSpyEnabled = enabled
end

local function handleRequest(data)
    local request = HttpService:JSONDecode(data)
    
    if not request.method then return end
    
    local handlers = {
        get_place_info = getPlaceInfo,
        scan_upvalues = scanUpvalues,
        scan_constants = scanConstants,
        scan_scripts = scanScripts,
        scan_modules = scanModules,
        get_remotes = getRemotes,
        execute = function() return executeCode(request.params.code) end,
        modify_upvalue = function() return modifyUpvalue(request.params) end,
        enable_remote_spy = function() enableRemoteSpy(request.params.enabled) return {} end,
        enable_closure_spy = function() enableClosureSpy(request.params.enabled) return {} end
    }
    
    local handler = handlers[request.method]
    if handler then
        local success, result = pcall(handler)
        if request.id then
            if success then
                sendResponse(request.id, result)
            else
                sendResponse(request.id, nil, tostring(result))
            end
        end
    elseif request.id then
        sendResponse(request.id, nil, "Unknown method: " .. request.method)
    end
end

function ExploUtor.connect(host, port)
    host = host or "localhost"
    port = port or 8080
    
    local url = string.format("ws://%s:%d", host, port)
    
    ws = WebSocket.connect(url)
    
    ws.OnMessage:Connect(function(message)
        local success, err = pcall(handleRequest, message)
        if not success then
            warn("[ExploUtor] Error handling request:", err)
        end
    end)
    
    ws.OnClose:Connect(function()
        ws = nil
        wait(5)
        ExploUtor.connect(host, port)
    end)
    
    print("[ExploUtor] Connected to", url)
end

function ExploUtor.disconnect()
    if ws then
        ws:Close()
        ws = nil
    end
end

return ExploUtor
