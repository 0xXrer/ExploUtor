local HttpService = game:GetService("HttpService")

local ExploUtor = {}
ExploUtor.__index = ExploUtor

local ws = nil
local remoteSpyEnabled = false
local remoteSpyConnection = nil

local function generateId()
	return HttpService:GenerateGUID(false)
end

local function serialize(value, depth)
	depth = depth or 0
	if depth > 5 then
		return "..."
	end

	local t = typeof(value)

	if t == "string" then
		return string.format("%q", value)
	elseif t == "number" or t == "boolean" then
		return tostring(value)
	elseif t == "nil" then
		return "nil"
	elseif t == "table" then
		local parts = {}
		local count = 0
		for k, v in pairs(value) do
			if count >= 20 then
				table.insert(parts, "...")
				break
			end
			local key = type(k) == "string" and k or "[" .. serialize(k, depth + 1) .. "]"
			table.insert(parts, key .. " = " .. serialize(v, depth + 1))
			count = count + 1
		end
		return "{" .. table.concat(parts, ", ") .. "}"
	elseif t == "Instance" then
		return value:GetFullName()
	elseif t == "function" then
		local info = debug.info(value, "sln")
		return string.format("function<%s>", info or "unknown")
	else
		return tostring(value)
	end
end

local function sendResponse(id, result, err)
	if not ws then
		return
	end
	local response = { jsonrpc = "2.0", id = id }
	if err then
		response.error = { code = -32000, message = err }
	else
		response.result = result
	end
	ws:Send(HttpService:JSONEncode(response))
end

local function sendNotification(method, params)
	if not ws then
		return
	end
	ws:Send(HttpService:JSONEncode({ jsonrpc = "2.0", method = method, params = params }))
end

local function getPlaceInfo()
	return {
		placeId = game.PlaceId,
		placeName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
		creatorId = game.CreatorId,
		creatorType = tostring(game.CreatorType),
		serverSize = #game:GetService("Players"):GetPlayers(),
	}
end

local function findInstances(params)
	local results = {}
	local query = (params.query or ""):lower()
	local ancestor = game

	if params.ancestor then
		local current = game
		for part in string.gmatch(params.ancestor, "[^.]+") do
			if part ~= "game" then
				current = current:FindFirstChild(part)
				if not current then
					return { instances = {} }
				end
			end
		end
		ancestor = current
	end

	for _, child in ipairs(ancestor:GetDescendants()) do
		if #results >= 50 then
			break
		end
		local match = child.Name:lower():find(query, 1, true)
		if match and (not params.className or child.ClassName == params.className) then
			table.insert(results, { name = child.Name, className = child.ClassName, path = child:GetFullName() })
		end
	end
	return { instances = results }
end

local function getChildren(params)
	local path = params.path or "game"
	local current = game
	for part in string.gmatch(path, "[^.]+") do
		if part ~= "game" then
			current = current:FindFirstChild(part)
			if not current then
				return { children = {} }
			end
		end
	end
	local children = {}
	for _, child in ipairs(current:GetChildren()) do
		table.insert(children, { name = child.Name, className = child.ClassName, path = child:GetFullName() })
	end
	return { children = children }
end

local function getProperties(params)
	local current = game
	for part in string.gmatch(params.path, "[^.]+") do
		if part ~= "game" then
			current = current:FindFirstChild(part)
			if not current then
				return { error = "Not found" }
			end
		end
	end

	local props = {}
	local propList = params.properties
		or {
			"Name",
			"ClassName",
			"Position",
			"Size",
			"CFrame",
			"Transparency",
			"Anchored",
			"CanCollide",
			"Text",
			"Value",
			"Enabled",
			"Visible",
		}
	for _, name in ipairs(propList) do
		pcall(function()
			props[name] = serialize(current[name])
		end)
	end

	local attrs = {}
	pcall(function()
		for k, v in pairs(current:GetAttributes()) do
			attrs[k] = serialize(v)
		end
	end)

	return {
		name = current.Name,
		className = current.ClassName,
		path = current:GetFullName(),
		properties = props,
		attributes = attrs,
	}
end

local function readScript(params)
	local current = game
	for part in string.gmatch(params.path, "[^.]+") do
		if part ~= "game" then
			current = current:FindFirstChild(part)
			if not current then
				return { source = "-- Not found" }
			end
		end
	end
	local source = ""
	pcall(function()
		source = decompile(current)
	end)
	return { path = current:GetFullName(), source = source }
end

local function getRemotes()
	local remotes = {}
	for _, child in ipairs(game:GetDescendants()) do
		if #remotes >= 100 then
			break
		end
		if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
			table.insert(remotes, { name = child.Name, path = child:GetFullName(), type = child.ClassName })
		end
	end
	return { remotes = remotes }
end

local function searchUpvalues(params)
	local results = {}
	local query = (params.query or ""):lower()

	for _, func in ipairs(getgc(true)) do
		if #results >= 50 then
			break
		end
		if typeof(func) == "function" and not iscclosure(func) then
			local funcInfo = debug.info(func, "sln") or "unknown"
			local funcName = debug.info(func, "n") or "anonymous"

			for i = 1, 50 do
				local ok, name, value = pcall(debug.getupvalue, func, i)
				if not ok or not name then
					break
				end

				local valStr = serialize(value)
				local valType = typeof(value)
				local match = name:lower():find(query, 1, true) or valStr:lower():find(query, 1, true)

				if match and (not params.type or valType == params.type) then
					table.insert(results, {
						name = name,
						value = valStr,
						type = valType,
						index = i,
						closureName = funcName,
						closureLocation = funcInfo,
					})
					if #results >= 50 then
						break
					end
				end
			end
		end
	end
	return { upvalues = results }
end

local function searchConstants(params)
	local results = {}
	local query = (params.query or ""):lower()

	for _, func in ipairs(getgc(true)) do
		if #results >= 50 then
			break
		end
		if typeof(func) == "function" and not iscclosure(func) then
			local funcInfo = debug.info(func, "sln") or "unknown"
			local funcName = debug.info(func, "n") or "anonymous"

			local ok, consts = pcall(debug.getconstants or getconstants, func)
			if ok and consts then
				for i, value in pairs(consts) do
					if value ~= nil then
						local valStr = serialize(value)
						local valType = typeof(value)
						local match = valStr:lower():find(query, 1, true)

						if match and (not params.type or valType == params.type) then
							table.insert(results, {
								value = valStr,
								type = valType,
								index = i,
								closureName = funcName,
								closureLocation = funcInfo,
							})
							if #results >= 50 then
								break
							end
						end
					end
				end
			end
		end
	end
	return { constants = results }
end

local function searchScripts(params)
	local results = {}
	local query = (params.query or ""):lower()
	local includeModules = params.includeModules ~= false

	for _, child in ipairs(game:GetDescendants()) do
		if #results >= 30 then
			break
		end
		local isScript = child:IsA("LocalScript") or (includeModules and child:IsA("ModuleScript"))
		if isScript and child.Name:lower():find(query, 1, true) then
			table.insert(results, { name = child.Name, className = child.ClassName, path = child:GetFullName() })
		end
	end
	return { scripts = results }
end

local function searchClosures(params)
	local results = {}
	local query = (params.query or ""):lower()

	for _, func in ipairs(getgc(true)) do
		if #results >= 30 then
			break
		end
		if typeof(func) == "function" and not iscclosure(func) then
			local funcName = debug.info(func, "n") or ""
			local funcInfo = debug.info(func, "sln") or "unknown"
			local match = funcName:lower():find(query, 1, true)

			if not match and params.searchConstants then
				local ok, consts = pcall(debug.getconstants or getconstants, func)
				if ok and consts then
					for _, v in pairs(consts) do
						if typeof(v) == "string" and v:lower():find(query, 1, true) then
							match = true
							break
						end
					end
				end
			end

			if match then
				table.insert(results, { name = funcName ~= "" and funcName or "anonymous", location = funcInfo })
			end
		end
	end
	return { closures = results }
end

local function executeCode(code)
	local ok, result = pcall(function()
		local fn, err = loadstring(code)
		if not fn then
			error(err)
		end
		return fn()
	end)
	return { success = ok, output = ok and serialize(result) or nil, error = not ok and tostring(result) or nil }
end

local function enableRemoteSpy(params)
	remoteSpyEnabled = params.enabled
	if params.enabled and not remoteSpyConnection then
		local old = hookmetamethod(game, "__namecall", function(self, ...)
			local method = getnamecallmethod()
			if remoteSpyEnabled and (method == "FireServer" or method == "InvokeServer") then
				if self:IsA("RemoteEvent") or self:IsA("RemoteFunction") then
					sendNotification("remote_called", {
						timestamp = os.time() * 1000,
						remoteName = self.Name,
						remotePath = self:GetFullName(),
						remoteType = self.ClassName,
						arguments = serialize({ ... }),
						traceback = debug.traceback(),
					})
				end
			end
			return old(self, ...)
		end)
		remoteSpyConnection = true
	end
	return {}
end

local handlers = {
	get_place_info = getPlaceInfo,
	find_instances = findInstances,
	get_children = getChildren,
	get_properties = getProperties,
	read_script = readScript,
	get_remotes = getRemotes,
	search_upvalues = searchUpvalues,
	search_constants = searchConstants,
	search_scripts = searchScripts,
	search_closures = searchClosures,
	execute = function(p)
		return executeCode(p.code)
	end,
	enable_remote_spy = enableRemoteSpy,
}

local function handleRequest(data)
	local req = HttpService:JSONDecode(data)
	if not req.method then
		return
	end

	local handler = handlers[req.method]
	if handler then
		local ok, result = pcall(handler, req.params or {})
		if req.id then
			sendResponse(req.id, ok and result or nil, not ok and tostring(result) or nil)
		end
	elseif req.id then
		sendResponse(req.id, nil, "Unknown: " .. req.method)
	end
end

function ExploUtor.connect(host, port)
	host, port = host or "localhost", port or 8080
	ws = WebSocket.connect(string.format("ws://%s:%d", host, port))
	ws.OnMessage:Connect(function(m)
		pcall(handleRequest, m)
	end)
	ws.OnClose:Connect(function()
		ws = nil
		wait(5)
		ExploUtor.connect(host, port)
	end)
	print("[ExploUtor] Connected")
end

function ExploUtor.disconnect()
	if ws then
		ws:Close()
		ws = nil
	end
end

return ExploUtor
